{"version":3,"file":"importSongsFromPostHog-kWytacZP.js","sources":["../../src/Songs/utils/importSongsFromPostHogBase.ts","../../src/Songs/utils/importSongsFromPostHog.ts"],"sourcesContent":["import { Song, SongPreview } from 'interfaces';\nimport convertTxtToSong from './convertTxtToSong';\nimport getSongId from './getSongId';\n\nconst API_URL = 'https://eu.posthog.com';\nconst PROJECT_ID = '281';\nconst AFTER_DATE = new Date(Date.now() - 1000 * 3600 * 24 * 28).toISOString();\n\nconst normalizeSong = (song: Song): Song => {\n  if (song.title.toLowerCase().trim().endsWith('[duet]')) {\n    song.title = song.title.slice(0, -6);\n  } else if (song.title.toLowerCase().endsWith('(tv)')) {\n    song.title = song.title.slice(0, -4);\n  } else if (song.title.toLowerCase().endsWith('(album version)')) {\n    song.title = song.title.slice(0, -15);\n  } else if (song.title.toLowerCase().endsWith('(movie version)')) {\n    song.title = song.title.slice(0, -15);\n  }\n  song.title = song.title.trim();\n\n  song.language = song.language.map((lang) => {\n    if (lang.toLowerCase().startsWith('espa')) {\n      return 'Spanish';\n    } else if (lang.toLowerCase().endsWith('(romanized)')) {\n      return lang.slice(0, -11).trim();\n    } else if (lang.toLowerCase().endsWith('(brazil)')) {\n      return 'Portuguese';\n    }\n    return lang;\n  });\n\n  song.lastUpdate = new Date().toISOString();\n\n  // @ts-ignore\n  song.id = undefined;\n  song.id = getSongId(song);\n\n  return song;\n};\n\ntype RequestFunc = (url: string) => Promise<any>;\n\nexport const importSongsFromPostHogBase = async (\n  mkRequest: RequestFunc,\n  currentSongs: SongPreview[],\n  fetchedSongIds: string[],\n  onSongAdded: (song: Song) => Promise<void>,\n) => {\n  const response = await mkRequest(\n    `${API_URL}/api/projects/${PROJECT_ID}/events?event=share-song&after=${AFTER_DATE}&limit=200`,\n  );\n\n  await Promise.all(\n    response.results.map(async (result: any) => {\n      try {\n        let song = convertTxtToSong(result.properties.song);\n        if (!song.id) {\n          console.log('Song has no ID', song);\n          return;\n        }\n        normalizeSong(song);\n\n        if (fetchedSongIds.includes(song.id)) {\n          console.log(`Song ${song.id} already fetched`);\n        } else if (!currentSongs.find((currentSong) => currentSong.id === song.id)) {\n          song.lastUpdate = new Date().toISOString();\n          await onSongAdded(song);\n          console.log(`Added song ${song.id}`);\n        } else {\n          console.log(`Song ${song.id} already exists`);\n        }\n      } catch (e) {\n        console.warn(`Couldn't convert song ${result.properties.song}`);\n      }\n    }),\n  );\n};\n","import SongsService from 'Songs/SongsService';\nimport { Song } from 'interfaces';\nimport { importSongsFromPostHogBase } from './importSongsFromPostHogBase';\n\nconst importSongsFromPostHog = async () => {\n  const posthogKey = sessionStorage.getItem('posthog_key') || prompt('Enter PostHog PAT');\n\n  if (!posthogKey) {\n    return;\n  }\n  sessionStorage.setItem('posthog_key', posthogKey);\n\n  const makeRequest = async (url: string) => {\n    const response = await fetch(url, {\n      headers: {\n        Authorization: `Bearer ${posthogKey}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Request failed with status ${response.status}`);\n    }\n\n    return response.json();\n  };\n\n  await importSongsFromPostHogBase(makeRequest, await SongsService.getIndex(true), [], async (song: Song) => {\n    return SongsService.store(song);\n  });\n};\n\nexport default importSongsFromPostHog;\n"],"names":["API_URL","PROJECT_ID","AFTER_DATE","Date","now","toISOString","normalizeSong","song","title","toLowerCase","trim","endsWith","slice","language","map","lang","startsWith","lastUpdate","id","undefined","getSongId","importSongsFromPostHogBase","mkRequest","currentSongs","fetchedSongIds","onSongAdded","response","Promise","all","results","result","convertTxtToSong","properties","log","includes","console","find","currentSong","warn","importSongsFromPostHog","posthogKey","sessionStorage","getItem","prompt","setItem","url","fetch","headers","Authorization","ok","Error","status","json","SongsService","getIndex","store"],"mappings":"iDAIA,MAAMA,EAAU,yBACVC,EAAa,MACbC,EAAa,IAAIC,KAAKA,KAAKC,IAAQ,EAAA,IAAO,KAAO,GAAK,EAAE,EAAEC,YAAY,EAEtEC,EAAiBC,IACjBA,EAAKC,MAAMC,YAAY,EAAEC,OAAOC,SAAS,QAAQ,EACnDJ,EAAKC,MAAQD,EAAKC,MAAMI,MAAM,EAAG,EAAE,EAC1BL,EAAKC,MAAMC,cAAcE,SAAS,MAAM,EACjDJ,EAAKC,MAAQD,EAAKC,MAAMI,MAAM,EAAG,EAAE,GAC1BL,EAAKC,MAAMC,cAAcE,SAAS,iBAAiB,GAEnDJ,EAAKC,MAAMC,cAAcE,SAAS,iBAAiB,KAC5DJ,EAAKC,MAAQD,EAAKC,MAAMI,MAAM,EAAG,GAAG,GAEjCJ,EAAAA,MAAQD,EAAKC,MAAME,KAAK,EAE7BH,EAAKM,SAAWN,EAAKM,SAASC,IAAcC,GACtCA,EAAKN,YAAAA,EAAcO,WAAW,MAAM,EAC/B,UACED,EAAKN,YAAcE,EAAAA,SAAS,aAAa,EAC3CI,EAAKH,MAAM,EAAG,GAAG,EAAEF,OACjBK,EAAKN,YAAcE,EAAAA,SAAS,UAAU,EACxC,aAEFI,CACR,EAEDR,EAAKU,WAAa,IAAId,KAAK,EAAEE,YAAY,EAGzCE,EAAKW,GAAKC,OACLD,EAAAA,GAAKE,EAAUb,CAAI,EAEjBA,GAKIc,EAA6B,MACxCC,EACAC,EACAC,EACAC,IACG,CACGC,MAAAA,EAAW,MAAMJ,EACpB,GAAEtB,CAAQ,iBAAgBC,CAAW,kCAAiCC,CAAW,YACpF,EAEA,MAAMyB,QAAQC,IACZF,EAASG,QAAQf,IAAI,MAAOgB,GAAgB,CACtC,GAAA,CACF,IAAIvB,EAAOwB,EAAiBD,EAAOE,WAAWzB,IAAI,EAC9C,GAAA,CAACA,EAAKW,GAAI,CACJe,QAAAA,IAAI,iBAAkB1B,CAAI,EAClC,MACF,CACAD,EAAcC,CAAI,EAEdiB,EAAeU,SAAS3B,EAAKW,EAAE,EACjCiB,QAAQF,IAAK,QAAO1B,EAAKW,EAAG,kBAAiB,EACnCK,EAAaa,QAAsBC,EAAYnB,KAAOX,EAAKW,EAAE,EAKvEiB,QAAQF,IAAK,QAAO1B,EAAKW,EAAG,iBAAgB,GAJ5CX,EAAKU,WAAa,IAAId,KAAK,EAAEE,YAAY,EACzC,MAAMoB,EAAYlB,CAAI,EACtB4B,QAAQF,IAAK,cAAa1B,EAAKW,EAAG,EAAC,QAI3B,CACViB,QAAQG,KAAM,yBAAwBR,EAAOE,WAAWzB,IAAK,EAAC,CAChE,CACD,CAAA,CACH,CACF,ECxEMgC,EAAyB,SAAY,CACzC,MAAMC,EAAaC,eAAeC,QAAQ,aAAa,GAAKC,OAAO,mBAAmB,EAEtF,GAAI,CAACH,EACH,OAEaI,eAAAA,QAAQ,cAAeJ,CAAU,EAgB1CnB,MAAAA,EAdc,MAAOwB,GAAgB,CACnCnB,MAAAA,EAAW,MAAMoB,MAAMD,EAAK,CAChCE,QAAS,CACPC,cAAgB,UAASR,CAAW,EACtC,CAAA,CACD,EAEG,GAAA,CAACd,EAASuB,GACZ,MAAM,IAAIC,MAAO,8BAA6BxB,EAASyB,MAAO,EAAC,EAGjE,OAAOzB,EAAS0B,MAAK,EAGuB,MAAMC,EAAaC,SAAS,EAAI,EAAG,GAAI,MAAO/C,GACnF8C,EAAaE,MAAMhD,CAAI,CAC/B,CACH"}