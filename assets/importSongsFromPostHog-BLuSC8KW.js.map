{"version":3,"file":"importSongsFromPostHog-BLuSC8KW.js","sources":["../../src/modules/Songs/utils/importSongsFromPostHogBase.ts","../../src/modules/Songs/utils/importSongsFromPostHog.ts"],"sourcesContent":["import { Song, SongPreview } from 'interfaces';\nimport convertTxtToSong from './convertTxtToSong';\nimport getSongId from './getSongId';\n\nconst API_URL = 'https://eu.posthog.com';\nconst PROJECT_ID = '281';\nconst AFTER_DATE = new Date(Date.now() - 1000 * 3600 * 24 * 28).toISOString();\n\nconst suffixes = ['(tv)', '(album version)', '(movie version)', '[duet]'];\n\nconst normalizeSong = (song: Song): Song => {\n  suffixes.forEach((suffix) => {\n    if (song.title.toLowerCase().endsWith(suffix)) {\n      song.title = song.title.slice(0, -suffix.length);\n    }\n  });\n  song.title = song.title.trim();\n\n  song.language = song.language.map((lang) => {\n    if (lang.toLowerCase().startsWith('espa')) {\n      return 'Spanish';\n    } else if (lang.toLowerCase().endsWith('(romanized)')) {\n      return lang.slice(0, -11).trim();\n    } else if (lang.toLowerCase().endsWith('(brazil)')) {\n      return 'Portuguese';\n    }\n    return lang;\n  });\n\n  song.lastUpdate = new Date().toISOString();\n\n  // @ts-expect-error reset id before generating a new one\n  song.id = undefined;\n  song.id = getSongId(song);\n\n  return song;\n};\n\ntype RequestOptions = {\n  body?: string;\n  method: 'post' | 'get';\n  headers?: HeadersInit;\n};\n\ntype RequestFunc = (url: string, options: RequestOptions) => Promise<any>;\n\nexport const importSongsFromPostHogBase = async (\n  mkRequest: RequestFunc,\n  currentSongs: SongPreview[],\n  fetchedSongIds: string[],\n  onSongAdded: (song: Song, createdAt: string) => Promise<void>,\n  onSongRemoved: (songId: string) => Promise<void>,\n  from?: string,\n) => {\n  const sharedSongs = await mkRequest(`${API_URL}/api/projects/${PROJECT_ID}/query`, {\n    method: 'post',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify({\n      query: {\n        kind: 'HogQLQuery',\n        query: `\n            select events.properties.song, events.properties.songId, events.created_at\n            from events\n            where events.created_at > toDateTime('${from ?? AFTER_DATE}')\n              and event IN ('share-song', 'unshare-song') and events.properties.$user_id !='3ab0feed-e1d2-4ff0-8780-5db00698eb60'\n            ORDER BY events.created_at ASC\n            LIMIT 300\n        `,\n      },\n    }),\n  });\n\n  const songsAdded: string[] = [];\n\n  for (const [songTxt, songId, createdAt] of sharedSongs.results as Array<[string, string, string]>) {\n    try {\n      if (!songTxt && songId && songsAdded.includes(songId)) {\n        await onSongRemoved(songId);\n        console.log(`Deleting song ${songId}`);\n      }\n\n      const song = convertTxtToSong(songTxt.replaceAll('\\\\n', '\\n').replaceAll('\\\\\"', '\"'));\n      if (!song.id) {\n        console.log('Song has no ID', song);\n        return;\n      }\n      normalizeSong(song);\n\n      if (fetchedSongIds.includes(song.id)) {\n        console.log(`Song ${song.id} already fetched`);\n      } else if ((song.tracks[0]?.sections.length ?? 0) < 5) {\n        console.log(`Song ${song.id} seems to be broken, ${song.tracks[0]?.sections.length} sections found`);\n      } else if (currentSongs.find((currentSong) => currentSong.id === song.id)) {\n        console.log(`Song ${song.id} already exists (by song id)`);\n      } else if (currentSongs.find((currentSong) => currentSong.video === song.video)) {\n        console.log(`Song ${song.id} already exists (by video id)`);\n      } else {\n        song.lastUpdate = new Date().toISOString();\n        songsAdded.push(song.id);\n        await onSongAdded(song, createdAt);\n        console.log(`Added song ${song.id}`);\n      }\n    } catch (e) {\n      console.warn(`Couldn't convert song ${songTxt}`, e);\n    }\n  }\n};\n","import { Song } from 'interfaces';\nimport SongsService from 'modules/Songs/SongsService';\nimport storage from 'modules/utils/storage';\nimport { importSongsFromPostHogBase } from './importSongsFromPostHogBase';\n\nconst importSongsFromPostHog = async () => {\n  const posthogKey = storage.session.getItem('posthog_key') || prompt('Enter PostHog PAT');\n\n  if (!posthogKey) {\n    return;\n  }\n  storage.session.setItem('posthog_key', posthogKey);\n\n  const defaultFrom = new Date();\n  defaultFrom.setDate(defaultFrom.getDate() - 10);\n\n  let from = prompt('Enter from', storage.local.getItem('posthog_from') || defaultFrom.toISOString());\n  if (from === null) {\n    return;\n  }\n  from = new Date(from).toISOString();\n\n  const makeRequest = async (url: string, options: RequestInit) => {\n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options.headers,\n        Authorization: `Bearer ${posthogKey}`,\n      },\n    });\n\n    if (!response.ok) {\n      throw new Error(`Request failed with status ${response.status}`);\n    }\n\n    return response.json();\n  };\n\n  let lastSongAdd: number = 0;\n\n  await importSongsFromPostHogBase(\n    makeRequest,\n    await SongsService.getIndex(true),\n    [],\n    async (song: Song, createdAt) => {\n      await SongsService.store(song, false);\n      const createdAtTime = new Date(createdAt).getTime();\n      if (createdAtTime > lastSongAdd) {\n        lastSongAdd = createdAtTime;\n      }\n    },\n    async (songId: string) => {\n      return SongsService.deleteSong(songId);\n    },\n    from,\n  );\n  storage.local.setItem('posthog_from', new Date(lastSongAdd).toISOString());\n};\n\nexport default importSongsFromPostHog;\n"],"names":["API_URL","PROJECT_ID","AFTER_DATE","Date","now","toISOString","suffixes","normalizeSong","song","forEach","suffix","title","toLowerCase","endsWith","slice","length","trim","language","map","lang","startsWith","lastUpdate","id","undefined","getSongId","importSongsFromPostHogBase","mkRequest","currentSongs","fetchedSongIds","onSongAdded","onSongRemoved","from","sharedSongs","method","headers","body","JSON","stringify","query","kind","songsAdded","songTxt","songId","createdAt","results","includes","console","log","convertTxtToSong","replaceAll","tracks","sections","find","currentSong","video","push","e","warn","importSongsFromPostHog","posthogKey","storage","session","getItem","prompt","setItem","defaultFrom","setDate","getDate","local","makeRequest","url","options","response","fetch","Authorization","ok","Error","status","json","lastSongAdd","SongsService","getIndex","store","createdAtTime","getTime","deleteSong"],"mappings":"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"}